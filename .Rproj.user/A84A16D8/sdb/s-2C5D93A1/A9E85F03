{
    "contents" : "#' Diagnostic Data Generator\n#'\n#' Calculate different error types on the given data and return an object of class \n#' data frame ready for usage in different diagnostics plots.\n#' \n#' @param fit an object of class lm that contains the result to fit a linear model \n#' regression.\n#' @return a data frame object with origin values, fitted values, and differents \n#' error types for make some diagnostics plots.\n#' @seealso ResidualsFitted, StResidualsFitted, NormalQQ, StResidualsLeverange\n#' @examples\n#' iris.x <- iris[,1:3]\n#' Petal.Width <- iris[,4]\n#' ir.pca <- prcomp(iris.x, center = TRUE, scale. = TRUE)\n#' PCA <- as.data.frame(ir.pca$x)\n#' \n#' PC1 <- PCA[,1]\n#' PC2 <- PCA[,2]\n#' PC3 <- PCA[,3]\n#' \n#' fit <- lm(Petal.Width ~ PC1 + PC2 + PC3, data = PCA)\n#' diagnostic <- diagnosticData(fit)\ndiagnosticData <- function(fit) {\n  \n  if (missing(fit)) {\n    stop(\"Need to specify fit!\")\n  }\n  else {\n    if (!('model' %in% names(fit))) {\n      stop(\"fit must be a closure type\")\n    }\n  }\n  \n  dependentVariableName <- \"Dependent Variable\"\n  \n  #All parameters are OK!\n  diagnostic <- data.frame(fit$model[,2:ncol(fit$model)])\n  dependentVariable <- data.frame(fit$model[,1])\n  names(dependentVariable) <- c(dependentVariableName)\n  \n  diagnostic <- data.frame(diagnostic, dependentVariable)\n  \n  resid <- resid(fit)\n  diagnostic <- data.frame(diagnostic, resid)\n  stz.r <- rstandard(fit)\n  diagnostic <- data.frame(diagnostic, stz.r)\n  stu.r <- rstudent(fit)\n  diagnostic <- data.frame(diagnostic, stu.r)\n  cooks <- cooks.distance(fit)\n  diagnostic <- data.frame(diagnostic, cooks)\n  dfbeta <- dfbeta(fit)\n  diagnostic <- data.frame(diagnostic, dfbeta)\n  dffit <- dffits(fit)\n  diagnostic <- data.frame(diagnostic, dffit)\n  leverage <- hatvalues(fit)\n  diagnostic <- data.frame(diagnostic, leverage)\n  cov.rat <- covratio(fit)\n  diagnostic <- data.frame(diagnostic, cov.rat)\n  fitted <- fitted(fit)\n  diagnostic <- data.frame(diagnostic, fitted)\n  sqrt.abs.stz.r <- sqrt(abs(diagnostic$stz.r))\n  diagnostic <- data.frame(diagnostic, sqrt.abs.stz.r)\n  \n  return (diagnostic)\n}\n\n#' Find Missing Values\n#'\n#' Check out all data set to find missing values. Return a data frame, with the \n#' possition of each missing value.\n#' \n#' @param dataSet an object of class data frame with a data set.\n#' @return an integer(0) when no null values, or a data frame with all null values\n#' identified by their positions (i,j)\n#' @seealso removeRowsMissing\n#' @examples\n#' NA_values <- findMissingValues(iris)\n#' \n#' if (any(NA_values)) { #Validation if missing values exist\n#'    #Do something with your missing values\n#' }\nfindMissingValues <- function (dataSet) {\n  \n  if (missing(dataSet)) {\n    stop(\"Need to specify dataSet!\")\n  }\n  \n  #All parameters are OK!\n  data <- data.frame(i=integer(), j=integer(), row.name=integer(), stringsAsFactors=FALSE)\n  count <- 0\n  for (i in 1:nrow(dataSet)) {\n    vector <- which(is.na(dataSet[i,]))\n    if (any(vector)) {\n      #The vector has null values!!!\n      for (j in 1:length(vector)) {\n        data[nrow(data)+1,1] <- i\n        data[nrow(data),2] <- vector[j]\n        data[nrow(data),3] <- as.integer(row.names(dataSet)[i])\n      }\n      count <- count + length(vector)\n    }\n  }\n  \n  if (count == 0) {\n    return (integer(0))\n  }\n  else {\n    return (data)\n  }\n}\n\n#' Remove Missing Values of Data Set\n#'\n#' Delete all rows of data set that contains a missing value.\n#' \n#' @param missingValues an object of class data frame with the possition (i,j) of \n#' each missing value.\n#' @param dataSet an object of class data frame with the original data set.\n#' @return an object of class data frame with a modified data set without missing \n#' values.\n#' @seealso findMissingValues\n#' @examples\n#' NA_values <- findMissingValues(iris)\n#' \n#' if (any(NA_values)) { #Validation if missing values exist\n#'    iris <- removeRowsMissing(NA_values, iris) #Remove all rows with missing values\n#' }\nremoveRowsMissing <- function (missingValues, dataSet) {\n  \n  if (missing(missingValues)) {\n    stop(\"Need to specify missingValues!\")\n  }\n  if (missing(dataSet)) {\n    stop(\"Need to specify dataSet!\")\n  }\n  \n  #All parameters are OK!\n  names <- row.names(dataSet)\n  j <- 1\n  i <- 1\n  while (i<=length(names) && j<=nrow(missingValues)) {\n    if (as.integer(names[i])==missingValues[j,3]) { #Remove row\n      dataSet <- dataSet[-i,] #Remove row\n      j <- j + 1\n    }\n    else {\n      if (as.integer(names[i]) > missingValues[j,3]) {\n        j <- j + 1\n      }\n      i <- i + 1\n    }\n  }\n  \n  return (dataSet)\n}\n\n#' Normalize Function\n#'\n#' Function to normalize data set in range of 0 to 1.\n#' \n#' @param dataSet an object of class data frame with the original data set.\n#' @return an object of class data frame with a modified data set normalized \n#' in range of 0 to 1.\n#' @seealso scaleData, normalizeData\n#' @examples\n#' iris.x <- iris[,1:4]\n#' normedIris <- as.data.frame(lapply(iris.x, normalize)) #In range [0,1]\nnormalize <- function(dataSet){\n  \n  if (missing(dataSet)) {\n    stop(\"Need to specify dataSet!\")\n  }\n  \n  #All parameters are OK!\n  (dataSet - min(dataSet, na.rm=TRUE))/(max(dataSet,na.rm=TRUE) - min(dataSet, na.rm=TRUE))\n}\n\n#' Scale Function\n#'\n#' Function to scale the data set. If you use normalize function first and then \n#' scaleData function you could obtain a normalize dataset in a range [x,y]\n#' \n#' @param dataSet an object of class data frame with the original data set.\n#' @param min an integer with the min value that you want scale the data set.\n#' @param max an integer with the max value that you want scale the data set.\n#' @return an object of class data frame with a modified data set scaled \n#' in the defined range.\n#' @seealso normalize, normalizeData\n#' @examples\n#' iris.x <- iris[,1:4]\n#' normed <- as.data.frame(lapply(iris.x, normalize))\n#' normedIris <- as.data.frame(lapply(normed, 1, 10, scaleData)) #In range [1,10]\nscaleData <- function(dataSet, min, max){\n  \n  if (missing(dataSet)) {\n    stop(\"Need to specify dataSet!\")\n  }\n  if (missing(min)) {\n    stop(\"Need to specify min!\")\n  }\n  if (missing(max)) {\n    stop(\"Need to specify max!\")\n  }\n  if (min >= max) {\n    stop(\"Min must be less strict than max!\")\n  }\n  \n  #All parameters are OK!\n  (dataSet * (max - min)) + min\n}\n\n#' Normalize Data Set\n#'\n#' Function to normalize a data set. You could normalize in any range [min,max], but\n#' if you don't specify this values, this function make a normalization in range\n#' [0,1].\n#' \n#' @param dataSet an object of class data frame with the original data set that you \n#' want normalize.\n#' @param min an integer with the min value that you want normalize the data set.\n#' @param max an integer with the max value that you want normalize the data set.\n#' @return an object of class data frame with a modified data set normalized \n#' in the defined range.\n#' @seealso normalize, scaleData\n#' @examples\n#' iris.x <- iris[,1:4]\n#' normedIris <- normalizeData(iris) #In range [0,1]\n#' normedIris <- normalizeData(iris, 1, 10) #In ragen [1,10]\nnormalizeData<- function(dataSet, min, max){\n  \n  if (missing(dataSet)) {\n    stop(\"Need to specify dataSet!\")\n  }\n  \n  #All parameters are OK!\n  try(\n    if (!missing(\"x\")) {\n      try(\n        if (!missing(\"y\")) {\n          normed <- as.data.frame(lapply(dataSet, normalize))\n          as.data.frame(lapply(normed, min, max, scaleData))\n        }, silent = TRUE)\n    }, silent = TRUE)\n  \n  as.data.frame(lapply(dataSet, normalize))\n}\n\n#' Calculate Variance Function\n#'\n#' Function to calculate de variance of an specific column.\n#' \n#' @param dataSet an object of class data frame with a data set that you want \n#' calculate the variance.\n#' @param col an integer that represent the column that you want calculate the\n#' variance.\n#' @return an object of class data frame with a modified data set with variance\n#' calculated.\n#' @seealso linePlot\n#' @examples\n#' iris.x <- iris[,1:4]\n#' ir.pca <- prcomp(iris.x, center = TRUE, scale. = TRUE)\n#' rowsData <- length(ir.pca$sdev)\n#' seqRow <- seq(from = 1, to = rowsData, length.out = rowsData)\n#' dataPlot <- data.frame(seqRow, ir.pca$sdev)\n#' dataPlot <- CalculateVariance(dataPlot, 2)\nCalculateVariance <- function(dataSet, col) {\n  \n  if (missing(dataSet)) {\n    stop(\"Need to specify dataSet!\")\n  }\n  if (missing(col)) {\n    stop(\"Need to specify col!\")\n  }\n  \n  #All parameters are OK!\n  for (i in 1:nrow(dataSet)) {\n    dataSet[i,col] <- dataSet[i,col]*dataSet[i,col]\n  }\n  return (dataSet)\n}\n\n#' Make Pairs Function\n#'\n#' Function that generate a data frame with the data used for ggplot function for\n#' make a scatterplot matrix.\n#' \n#' @param dataSet an object of class data frame with a data set.\n#' @return an object of class data frame with the data used for ggplot function.\n#' @seealso ScatterplotMatrix\n#' @source https://gastonsanchez.wordpress.com/2012/08/27/scatterplot-matrices-with-ggplot/\n#' @examples\n#' iris.x <- iris[,1:4]\n#' ir.pca <- prcomp(iris.x, center = TRUE, scale. = TRUE)\n#' gg1 <- makePairs(ir.pca$x)\nmakePairs <- function(dataSet){\n  \n  if (missing(dataSet)) {\n    stop(\"Need to specify dataSet!\")\n  }\n  \n  #All parameters are OK!\n  grid <- expand.grid(x = 1:ncol(dataSet), y = 1:ncol(dataSet))\n  grid <- subset(grid, x != y)\n  all <- do.call(\"rbind\", lapply(1:nrow(grid), function(i) {\n    xcol <- grid[i, \"x\"]\n    ycol <- grid[i, \"y\"]\n    data.frame(xvar = names(dataSet)[ycol], yvar = names(dataSet)[xcol], \n               x = dataSet[, xcol], y = dataSet[, ycol], dataSet)\n  }))\n  all$xvar <- factor(all$xvar, levels = names(dataSet))\n  all$yvar <- factor(all$yvar, levels = names(dataSet))\n  densities <- do.call(\"rbind\", lapply(1:ncol(dataSet), function(i) {\n    data.frame(xvar = names(dataSet)[i], yvar = names(dataSet)[i], x = dataSet[, i])\n  }))\n  list(all = all, densities = densities)\n}\n\nremoveRowsByRowName <- function (remove, dataSet) {\n  \n  if (missing(remove)) {\n    stop(\"Need to specify remove!\")\n  }\n  if (missing(dataSet)) {\n    stop(\"Need to specify dataSet!\")\n  }\n  \n  #All parameters are OK!\n  names <- row.names(dataSet)\n  j <- 1\n  i <- 1\n  while (i<=length(names) && j<=length(remove)) {\n    if (as.integer(names[i])==remove[j]) { #Remove row\n      dataSet <- dataSet[-i,] #Remove row\n      j <- j + 1\n    }\n    else {\n      if (as.integer(names[i]) > remove[j]) {\n        j <- j + 1\n      }\n      i <- i + 1\n    }\n  }\n  \n  return (dataSet)\n}",
    "created" : 1445648568409.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "919539865",
    "id" : "A9E85F03",
    "lastKnownWriteTime" : 1445831996,
    "path" : "C:/Users/Mary Iturriaga/Desktop/RegressionLibs/R/RegressionLibs.R",
    "project_path" : "R/RegressionLibs.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}